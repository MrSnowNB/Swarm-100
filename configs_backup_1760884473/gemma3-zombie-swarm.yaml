---
project: gemma3-zombie-swarm
version: 1.0.0
status: active
last_updated: 2025-10-19

description: >
  Self-healing swarm using Gemma3:270M and the Zombie Protocol.
  Dead bots ("zombies") are resurrected by reconstructing their state
  from the average vectors of the K nearest healthy neighbors.

architecture:
  model:
    name: "gemma3:270m"
    quantization: "Q4"
    context_length: 2048
    temperature: 0.7
    top_p: 0.9
    top_k: 40
    notes: >
      Gemma3:270M is lightweight (<1GB VRAM) and ideal for high-concurrency swarms.
      Its minimal model load latency allows near-real-time self-healing.

  swarm_topology:
    gpus:
      - id: 0
        capacity_vram_gb: 48
        max_bots: 50
      - id: 1
        capacity_vram_gb: 48
        max_bots: 50
      - id: 2
        capacity_vram_gb: 48
        max_bots: 50
      - id: 3
        capacity_vram_gb: 48
        max_bots: 50
    communication_mode: "HTTP+JSON"
    base_port: 11400
    inter_node_hops: 4
    fanout: 5
    gossip_interval_s: 5
    self_healing_check_interval_s: 30

modules:
  - name: BotWorker
    description: >
      Each BotWorker runs Gemma3:270M, exposing /state and /health endpoints.
      Responds to gossip and participates in neighbor averaging for repair.
    memory:
      embeddings_vector_dim: 512
      storage_policy: "ring_buffer"
      max_vectors: 1000
    api_endpoints:
      - /state
      - /health
      - /reconstruct
    warm_start_policy:
      type: "nearest_neighbor_average"
      neighbors_to_query: 3
      merge_strategy: "mean"
      recovery_modes:
        - partial_copy
        - centroid_warmstart
    failure_policy:
      max_inactive_time_s: 120
      on_failure: "mark_dead"
      on_recovery: "spawn_zombie"

  - name: ZombieSupervisor
    description: >
      Watches all bot processes. Detects crashes, restarts bots as zombies,
      and requests nearest-neighbor states for reinitialization.
    responsibilities:
      - detect_dead_bots
      - compute_neighbor_proximity
      - trigger_reconstruction
      - restart_bots_with_state
    detection:
      strategy: "ps_check"
      grace_period_s: 60
    reconstruction:
      algorithm: "KNN_Average"
      parameters:
        k: 3
        weight_decay: 0.9
        time_window_s: 300
    logging:
      log_file: logs/zombie_supervisor.log
      log_rotation: daily
    recovery_example:
      event_trigger: bot_1_07_dead
      actions:
        - log event
        - query neighbors 1_06,1_08,2_00 for state vectors
        - compute average vector
        - reinstantiate bot with averaged state memory
        - mark bot_1_07 "zombie_reborn"

zombie_protocol:
  version: 2.1
  description: >
    Implements automated resurrection of dead bots as zombies using nearest-neighbor interpolation.
    Bots that were dead longer than 5 minutes are cold-started instead.

  conditions:
    - If bot marked_dead and inactivity_time < 300s:
        protocol_step:
          1. Request /state vectors from K neighbors via REST.
          2. Average vectors with time-decayed weighting.
          3. Spin up identical bot process on same GPU/port.
          4. Restore averaged memory vectors into bot context.
          5. Broadcast "rebirth" event.
    - If bot marked_dead >= 300s:
        protocol_step:
          1. Cold restart without neighbor state.
          2. Mark as "resurrected_cold".

  logging:
    level: INFO
    on_rebirth: "log_to_zombie_registry"
    metrics:
      - zombies_reborn: total successful recoveries
      - zombies_failed: total recovery failures

process_supervision:
  check_interval_s: 15
  metrics: ["alive_bots", "dead_bots", "reborn_zombies"]
  recovery_threshold:
    max_concurrent_restarts: 4
    cooldown_s: 60

monitoring:
  external_tools:
    process_monitor: "htop or glances"
    gpu_monitor: "nvtop or gpustat"
    network_monitor: "ss -tunap | grep :11434"
  alert_triggers:
    - condition: zombie_failure_rate > 0.25
      action: "send_alert('Zombie recovery unstable')"
    - condition: bot_survival_rate < 0.80
      action: "reduce_bot_count_per_gpu"

testing_phase:
  stage_1:
    bots_per_gpu: 10
    stagger_s: 3
    objective: "Verify zombie rebirth consistency"
  stage_2:
    bots_per_gpu: 25
    stagger_s: 1
    objective: "Full-scale recovery under moderate load"
  stage_3:
    bots_per_gpu: 50
    stagger_s: 0.5
    objective: "Stress test memory and nearest-neighbor reliability"

output_metrics:
  - mean_recovery_time_s
  - active_zombie_count
  - average_vector_similarity
  - bot_uptime_percent
  - swarm_resilience_index

deployment:
  start_command: "python3 scripts/launch_swarm.py"  # Uses configs/swarm_config.yaml
  supervisor_command: "python3 scripts/zombie_supervisor.py --config configs/gemma3-zombie-swarm.yaml"
  bot_command: "scripts/bot_worker_zombie.py"  # Auto-spawned for zombies
  model_pull: "ollama pull gemma3:270m"
  recovery_test:
    simulate_death: "kill -9 <bot_pid>"
    observe_recovery: "tail -f logs/zombie_supervisor.log | grep -E '(reborn|reconstructed)'"
  cleanup_command: "bash scripts/stop_swarm.sh && pkill -f zombie_supervisor"

llm_model_load_instructions: |
  # Pull and verify Gemma3 model
  ollama pull gemma3:270m
  ollama list | grep gemma3

  # For production deployment on MLC LLM or similar:
  # pip install mlc-llm mlc-ai-nightly
  # mlc_llm generate --model gemma3:270m --prompt "test"

current_success_metrics:
  phase_1_validate:
    total_bots: 40
    survival_rate: 100%
    launch_time_per_bot: 10s
    stable_runtime: 180s
    health_check_pass_rate: 100%

integration_notes: |
  - Use launch_swarm.py to start 100-bot deployment as normal
  - Run zombie_supervisor.py in background for monitoring/recovery
  - Bots auto-switch to zombie_worker on resurrection
  - Monitor reconstruction logs for tuning KNN parameters

# =============================================================================
# SUCCESS ANALYSIS & NEXT PHASE DEPLOYMENT
# =============================================================================

success_analysis:
  fixes_applied:
    - stagger_delay_s: 10  # Prevents resource flooding (was killing bots)
    - soft_health_check: removed  # Bots warn instead of exiting on first failure
    - ollama_prepopulation: ensured  # Model ready before launching bots
    - startup_grace_period_s: 30  # Health monitoring defers criticism during init

  performance_achieved:
    vram_per_bot_gb: 2-4  # Granite4:micro-h Q4
    bots_per_gpu_capacity: 10  # Out of 50 potential
    resource_utilization: 20-40  # GB per GPU (comfortable headroom)
    recovered_from_previous_failures: yes  # From constant crashes

next_phase_strategy:
  phase_1_complete_bots_40: |
    Status: âœ… OPERATIONAL
    Metrics: 100% survival, stable
    Next: Fix zombie bot integration

  phase_2_zombie_integration: |
    Objective: Launch zombie-enabled bots for resurrection testing
    Action: Modify launcher to use bot_worker_zombie.py with Flask APIs
    Expected: Supervisor can monitor and resurrect dead zombie bots

  phase_3_resurrection_validation: |
    Objective: Test KNN state reconstruction under live conditions
    Action: Kill 2-3 bots and verify resurrection with neighbor state
    Expected: Bots reborn within 60-90s, recovered state preserved

  phase_4_scaling_80_bots: |
    Prerequisites: Zombie protocol validated 95%+ success
    Action: Scale to 20 bots/GPU (80 total)
    Expected: VIOLATION 40-80GB VRAM usage, 95%+ survival

  phase_5_full_deployment_100: |
    Prerequisites: Phase 4 success with stable self-healing
    Action: Scale to 25 bots/GPU (100 total)
    Expected: Full capacity testing, resilience under load

  phase_6_gemma3_migration: |
    Prerequisites: Granite4:miro-h stable at 100 bots
    Action: Switch to Gemma3:270M for 200+ bot capability
    Expected: <1GB per bot, extreme concurrency

monitoring_procedures:
  multi_terminal_setup: |
    # Terminal 1: Launch process
    python3 scripts/launch_swarm.py

    # Terminal 2: Process count monitoring
    watch -n 2 "echo 'Active Bots:' && ps aux | grep bot_worker | grep -v grep | wc -l"

    # Terminal 3: GPU memory tracking
    watch -n 3 "nvidia-smi --query-gpu=index,memory.used,memory.total --format=csv,noheader"

    # Terminal 4: Zombie supervisor
    python3 scripts/zombie_supervisor.py --config configs/gemma3-zombie-swarm.yaml

    # Terminal 5: Live deployment logs
    tail -f logs/swarm_manager.log | grep -E "(deployed|alive|healthy)"

performance_targets_by_phase:
  phase_3_resurrection_test:
    recovery_time_s: 60-90
    state_similarity: 0.85  # Vector reconstruction accuracy
    concurrent_rebirth_max: 4

  phase_4_80_bots:
    total_launch_time_min: 13-15
    vram_usage_gb_per_gpu: 40-80
    survival_rate_percent: 95

  phase_5_100_bots:
    uptime_hours_target: 1
    failure_recovery_events: "<5"

troubleshooting_scalability:
  high_zombie_rate_issue: |
    Symptoms: >20% bots dying during launch
    Causes: Too many concurrent connections to Ollama, resource exhaustion
    Fixes:
    - Increase stagger_delay_s to 15-20
    - Reduce bots_per_gpu temporarily
    - Check Ollama connection limits

  resurrection_failure_issue: |
    Symptoms: Zombie supervisor detects dead bots but fails to resurrect
    Causes: Flask API unreachable, state calculation errors, neighbor unavailability
    Fixes:
    - Check /state endpoints: curl http://localhost:11400/health
    - Increase K neighbors in zombie_supervisor.py reconstruction params
    - Verify numpy/flask dependencies

  memory_pressure_issue: |
    Symptoms: Unstable bot survival beyond certain count
    Causes: GPU memory exhaustion, VRAM fragmentation
    Fixes:
    - Monitor: watch 'nvidia-smi --query-gpu=memory.used --format=csv,noheader'
    - Reduce batch_size in bot configuration
    - Switch to lower quantization (Q8_K_S if using GGUF models)

critical_success_indicators:
  - launch_survival_rate: ">95% (was 37% previously)"
  - resurrection_success_rate: ">90% within 90s"
  - stable_runtime_hours: ">1 hour at target scale"
  - zombie_registry_completeness: "Full event logging"

production_readiness_checklist:
  - survived_launch_stress_test: "Phase 1 âœ…"
  - zombie_resurrection_functional: "Phase 3 next"
  - scaled_to_target_bots: "Phase 5"
  - external_monitoring_integrated: "htop + nvtop + ss"
  - chaos_engineering_tested: "manual bot kills"
  - configuration_documented: "YAML with integrated guide"

# =============================================================================
# FINAL DEPLOYMENT GUIDE
# =============================================================================

deployment_readiness:
  repository: https://github.com/MrSnowNB/Swarm-100
  status: production_ready
  last_validated: 2025-10-19

verification_steps:
  - step: 1_verify_model
    command: "ollama pull gemma3:270m && ollama list | grep gemma3"
    expected: "gemma3:270m listed"

  - step: 2_verify_scripts
    command: "ls scripts/{launch_swarm.py,bot_worker_zombie.py,zombie_supervisor.py}"
    expected: "all three scripts present"

  - step: 3_verify_config
    command: "cat configs/swarm_config.yaml | grep gemma3"
    expected: "model: gemma3:270m"

  - step: 4_verify_dependencies
    command: "pip3 list | grep -E 'flask|pyyaml|requests'"
    expected: "all installed"

launch_sequence:
  phase_1_initial_bootstrap: |
    # Small test (10 bots/GPU)
    cd ~/Swarm-100
    vim configs/swarm_config.yaml  # Set bots_per_gpu: 10
    python3 scripts/launch_swarm.py &
    sleep 30
    ps aux | grep bot_worker_zombie | grep -v grep | wc -l  # Expected: 40

  phase_2_zombie_supervisor: |
    # Separate terminal
    python3 scripts/zombie_supervisor.py --config configs/gemma3-zombie-swarm.yaml &

  phase_3_testing_zombie_protocol: |
    # Find and kill a bot
    BOT_PID=$(ps aux | grep bot_worker_zombie | head -1 | awk '{print $2}')
    kill -9 $BOT_PID

    # Monitor recovery
    tail -f logs/zombie_supervisor.log | grep -E "(detected dead|reborn|reconstructed)"

  phase_4_full_scale_deployment: |
    # Stop current, scale to 50 bots/GPU
    bash scripts/stop_swarm.sh
    vim configs/swarm_config.yaml  # Set bots_per_gpu: 50
    python3 scripts/launch_swarm.py

monitoring_with_external_tools:
  tmux_session_setup: |
    tmux new -s swarm-monitor

    # Pane 1: Bot count
    watch -n 1 "echo 'Active Bots:' && ps aux | grep bot_worker_zombie | grep -v grep | wc -l"

    # Pane 2: GPU memory
    watch -n 2 "nvidia-smi --query-gpu=index,memory.used,memory.total,utilization.gpu --format=csv,noheader"

    # Pane 3: Zombie stats
    watch -n 5 "echo 'Zombie Stats:' && grep -c reborn logs/zombie_supervisor.log 2>/dev/null || echo 0"

    # Pane 4: Recent logs
    tail -f logs/zombie_supervisor.log | grep --line-buffered -E 'reborn|failed|detected'

expected_performance_metrics:
  gemma3_270m_q4:
    vram_per_bot_gb: 0.4-0.6
    bots_per_ada6000: 50-80
    model_load_time_s: 1-3
    inference_latency_ms: 100-500

  zombie_recovery:
    detection_time_s: 30-60
    neighbor_query_time_s: 5-15
    restart_time_s: 3-10
    total_recovery_time_s: 40-85

  swarm_resilience:
    target_uptime_percent: 95
    max_acceptable_zombie_rate: 0.15
    recovery_success_rate: 0.90

troubleshooting_guide:
  issue_bots_not_starting: |
    ollama list | grep gemma3
    ss -tulpn | grep 114 | wc -l
    tail -50 logs/gpu0/bot_00.log

  issue_zombie_recovery_failing: |
    cat bots/swarm_state.yaml | grep -A5 bots
    curl http://localhost:11400/health
    python3 -c "import requests; print(requests.get('http://localhost:11401/state').json())"

  issue_high_zombie_rate: |
    # Increase check interval and reduce bots temporarily
    vim scripts/zombie_supervisor.py  # check_interval_s: 15 â†’ 30
    vim configs/swarm_config.yaml      # bots_per_gpu: 50 â†’ 30
    bash scripts/stop_swarm.sh && python3 scripts/launch_swarm.py

integration_with_existing_features:
  tracing_integration: "DEBUG"
  health_monitoring: "Enhanced with grace periods"
  swarm_debug_analyzer: "Compatible with zombie_registry.yaml"
  ca_grid_lora: "Future integration for state preservation"

research_milestones:
  - milestone_1: "Whitepaper draft - document Zombie Protocol methodology"
  - milestone_2: "Advanced KNN optimization - adaptive K and RL weighting"
  - milestone_3: "Distributed memory - preserve CA grid through recovery"
  - milestone_4: "Chaos engineering - multi-node 200+ bot stress testing"

# =============================================================================
# WEB DASHBOARD ARCHITECTURE - Phase Progression
# =============================================================================

web_dashboard_architecture:
  description: |
    Modular web front-end that begins as swarm monitor and evolves into
    interactive human-in-the-loop chat dashboard

  phase_progression:
    phase_1_browser_monitor:
      status: "Current - Basic Flask app"
      description: "Simple HTML view for swarm status + /json endpoint for live data"
      components:
        - swarm_monitor.py: "Flask application serving status dashboard"
        - HTML_template: "Basic table showing bot health, GPU usage, zombie events"
        - "/json endpoint": "Returns live state data for dashboard"

    phase_2_websocket_realtime:
      status: "Next - Add Socket.IO layer"
      description: "Flask-SocketIO for real-time event streaming from bots/supervisor"
      dependencies:
        - "flask-socketio"
        - "eventlet"
      features:
        - Real-time process count updates
        - Live GPU memory monitoring
        - Zombie recovery event streaming
      api_endpoints:
        - "/trigger_update": "Push updates to all connected browsers"
        - "socket.emit('update')": "Broadcast state changes"
      browser_integration: |
        socket.on('update', data => { refreshUI(data) })

    phase_3_human_swarm_chat:
      status: "Future - Add chat interface"
      description: "Web chat box for human-swarm interaction"
      features:
        - Bi-directional messaging
        - Human-to-swarm message routing
        - Swarm-to-human response display
      chat_handlers: |
        @socketio.on('human_message')
        def handle_human(msg):
            emit('swarm_message', {'from':'bot', 'text':f"Echo: {msg}"}, broadcast=True)
      frontend_html: |
        <input id="msg" placeholder="Say hiâ€¦" onkeydown="sendMsg()">
        socket.on('swarm_message', appendMessage)

    phase_4_advanced_features:
      status: "Long-term - Full cockpit interface"
      features:
        - React/Vue.js frontend migration
        - User authentication
        - Advanced visualization (charts, graphs)
        - Command injection controls
        - Historical event playback
        - Performance metrics dashboard

  implementation_roadmap:
    data_layer:
      today: "Read swarm_state.yaml + log parsing"
      future: "REST APIs or Redis message bus"
    realtime_transport:
      today: "Flask-SocketIO"
      future: "Redis pub/sub for scaling"
    state_management:
      today: "Simple dict with timestamp"
      future: "Redis cache with persistence"
    ui_framework:
      today: "Plain HTML/JS"
      future: "React dashboard components"

  deployment_considerations:
    minimal_today:
      command: "python3 scripts/swarm_monitor.py"
      ports: "5000 (web dashboard)"
      dependencies: "flask, pyyaml"

    scalable_future:
      command: "gunicorn -k eventlet -w 1 swarm_monitor:wsgi_app"
      proxied: "nginx reverse proxy"
      dockerized: "Flask app containerized"

  integration_points:
    zombie_supervisor: "Can POST to /trigger_update after recoveries"
    bot_workers: "Emit to socket topic for activity updates"
    external_monitors: "htop/nvtop data fed via websocket"
    human_override: "Chat commands for swarm control"

  browser_dashboard_start:
    install_dependencies: "pip install flask-socketio eventlet"
    run_monitor: "python3 scripts/swarm_monitor.py"
    access_url: "http://localhost:5000 (status table)"
    test_realtime: "Open multiple browser tabs, watch live updates"

final_commands_summary: |
  # Full deployment
  cd ~/Swarm-100
  ollama pull gemma3:270m
  pip3 install flask pyyaml requests

  # Launch sequence
  python3 scripts/launch_swarm.py &
  python3 scripts/zombie_supervisor.py --config configs/gemma3-zombie-swarm.yaml &

  # Web dashboard (Phase 2)
  python3 scripts/swarm_monitor.py &

  # Monitor
  tmux new -s monitor
  watch -n 1 "ps aux | grep bot_worker_zombie | wc -l"

  # Test recovery
  kill -9 $(ps aux | grep bot_worker_zombie | head -1 | awk '{print $2}')
  tail -f logs/zombie_supervisor.log

  # Validate
  grep -c reborn logs/zombie_supervisor.log

  # Web dashboard access
  open http://localhost:5000
